diff -ur --unidirectional-new-file pcc-1.0.0/cc/cc/cc.c pcc/cc/cc/cc.c
--- pcc-1.0.0/cc/cc/cc.c	2011-03-15 20:25:36.000000000 +0100
+++ pcc/cc/cc/cc.c	2013-09-11 19:46:33.156788000 +0200
@@ -284,6 +284,7 @@
 /*
  * Wide char defines.
  */
+ #if 0
 #if WCHAR_TYPE == USHORT
 #define	WCT "short unsigned int"
 #define WCM "65535U"
@@ -305,6 +306,11 @@
 #else
 #error WCHAR_TYPE not defined or invalid
 #endif
+ #endif
+
+#define WCT "int"
+#define WCM "2147483647"
+
 
 #ifdef GCC_COMPAT
 #ifndef REGISTER_PREFIX
@@ -1143,6 +1149,11 @@
 				}
 			}
 		}
+#ifdef __helenos__
+		av[j++] = "-T";
+		av[j++] = "/inc/_link.ld";
+#endif
+		
 		av[j++] = 0;
 		eflag |= callsys(ld, av);
 		if (nc==1 && nxo==1 && eflag==0)
@@ -1326,6 +1337,63 @@
 	return (exitCode != 0);
 }
 
+#elif defined(__helenos__)
+
+#include <task.h>
+
+int callsys(char *f, char *v[])
+{
+	size_t len;
+	char *path = NULL;
+	const char *s;
+	int t;
+	task_exit_t texit;
+	int retval;
+	
+	task_id_t tid;
+	
+	if (vflag) {
+		fprintf(stderr, "%s ", f);
+		for (t = 1; v[t]; t++)
+			fprintf(stderr, "%s ", v[t]);
+		fprintf(stderr, "\n");
+	}
+	
+	if (Bflag) {
+		len = strlen (Bflag) + 8;
+		path = malloc (len);
+		if (path == NULL) {
+			error("callsys: malloc failed");
+			exit(1);
+		}
+		if ((s = strrchr(f, '/'))) {
+			strlcpy(path, Bflag, len);
+			strlcat(path, s, len);
+			if (task_spawnv(&tid, path, v) == 0)
+				goto _wait;
+		}
+	}
+	
+	if (task_spawnv(&tid, f, v) == 0)
+		goto _wait;
+	
+	if ((s = strrchr(f, '/')) && task_spawnv (&tid, s + 1, v) == 0) 
+		goto _wait;
+	
+	errorx(8, "Can't find %s\n", f);
+	return 0;
+	
+_wait:
+	
+	
+	if (task_wait (tid, &texit, &retval) != 0) {
+		error("Couldn't wait on task");
+		return 0;
+	}
+	
+	return retval;
+}
+
 #else
 
 int
diff -ur --unidirectional-new-file pcc-1.0.0/cc/cc/Makefile pcc/cc/cc/Makefile
--- pcc-1.0.0/cc/cc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/cc/Makefile	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,49 @@
+#
+# Copyright (c) 2011 Jiri Zarevucky
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# - Redistributions of source code must retain the above copyright
+#   notice, this list of conditions and the following disclaimer.
+# - Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in the
+#   documentation and/or other materials provided with the distribution.
+# - The name of the author may not be used to endorse or promote products
+#   derived from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+MIPDIR = ../../mip
+ARCHDIR = ../../arch/$(PLATFORM)
+OSDIR = ../../os/helenos
+EXTRA_CFLAGS = -I$(MIPDIR) -I$(ARCHDIR) -I$(OSDIR) -w
+DEFS = -Dmach_$(PLATFORM) -D__helenos__
+BINARY = cc
+
+PRE_DEPEND = compat.c
+EXTRA_CLEAN = compat.c
+
+POSIX_COMPAT = y
+
+SOURCES = \
+	cc.c \
+	compat.c
+
+include $(USPACE_PREFIX)/Makefile.common
+
+compat.c: $(MIPDIR)/compat.c
+	ln -s -f $^ $@
+
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/amd64/external.c pcc/cc/ccom/arch/amd64/external.c
--- pcc-1.0.0/cc/ccom/arch/amd64/external.c	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/amd64/external.c	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,244 @@
+#include "pass2.h"
+static int op0[] = { -1 };
+static int op1[] = { -1 };
+static int op2[] = { 193, 194, 195, 196, 197, 198, 199, 200, 201, 218, 220, -1 };
+static int op3[] = { -1 };
+static int op4[] = { 193, 194, 195, 196, 197, 198, 199, 200, 201, 218, 220, -1 };
+static int op5[] = { 193, 194, 195, 196, 197, 198, 199, 200, 201, 218, 220, -1 };
+static int op6[] = { 193, 194, 195, 196, 197, 198, 199, 200, 201, 218, 220, -1 };
+static int op7[] = { 193, 194, 195, 196, 197, 198, 199, 200, 201, 218, 220, -1 };
+static int op8[] = { 193, 194, 195, 196, 197, 198, 199, 200, 201, 218, 220, -1 };
+static int op9[] = { 219, 220, -1 };
+static int op10[] = { 70, 71, 72, 73, 74, 75, 76, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 220, -1 };
+static int op11[] = { 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 220, -1 };
+static int op12[] = { 146, 147, 148, 149, 150, 151, 152, 153, 220, -1 };
+static int op13[] = { 154, 155, 156, 157, 158, 159, 220, -1 };
+static int op14[] = { 160, 161, 162, 163, 164, 165, 220, -1 };
+static int op15[] = { 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 182, 183, 184, 185, 186, 187, 188, 189, 190, 220, -1 };
+static int op16[] = { 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 220, -1 };
+static int op17[] = { 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 220, -1 };
+static int op18[] = { 95, 96, 97, 98, 99, 100, 101, 102, 220, -1 };
+static int op19[] = { 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 220, -1 };
+static int op20[] = { 208, 209, 210, 211, 219, 220, -1 };
+static int op21[] = { -1 };
+static int op22[] = { -1 };
+static int op23[] = { 166, 167, 168, 169, 170, 171, 214, 219, 220, -1 };
+static int op24[] = { 202, 203, 204, 205, 206, 207, 219, 220, -1 };
+static int op25[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op26[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op27[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op28[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op29[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op30[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op31[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op32[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op33[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op34[] = { 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 220, -1 };
+static int op35[] = { 220, -1 };
+static int op36[] = { 217, 219, 220, -1 };
+static int op37[] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 219, 220, -1 };
+static int op38[] = { 1, 2, 219, 220, -1 };
+static int op39[] = { 220, -1 };
+static int op40[] = { 220, -1 };
+static int op41[] = { 48, 50, 52, 54, 56, 58, 60, 62, 220, -1 };
+static int op42[] = { 49, 51, 53, 55, 57, 59, 61, 63, 219, 220, -1 };
+static int op43[] = { 220, -1 };
+static int op44[] = { 219, 220, -1 };
+static int op45[] = { 67, 68, 69, 220, -1 };
+static int op46[] = { 64, 65, 66, 219, 220, -1 };
+static int op47[] = { 218, 220, -1 };
+static int op48[] = { 220, -1 };
+static int op49[] = { 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 215, -1 };
+static int op50[] = { 145, 216, -1 };
+static int op51[] = { 212, 219, 220, -1 };
+static int op52[] = { 219, 220, -1 };
+static int op53[] = { 220, -1 };
+static int op54[] = { 191, 192, 219, 220, -1 };
+static int op55[] = { -1 };
+static int op56[] = { 220, -1 };
+static int op57[] = { 219, 220, -1 };
+static int op58[] = { 213, 219, 220, -1 };
+
+int *qtable[] = { 
+	op0,
+	op1,
+	op2,
+	op3,
+	op4,
+	op5,
+	op6,
+	op7,
+	op8,
+	op9,
+	op10,
+	op11,
+	op12,
+	op13,
+	op14,
+	op15,
+	op16,
+	op17,
+	op18,
+	op19,
+	op20,
+	op21,
+	op22,
+	op23,
+	op24,
+	op25,
+	op26,
+	op27,
+	op28,
+	op29,
+	op30,
+	op31,
+	op32,
+	op33,
+	op34,
+	op35,
+	op36,
+	op37,
+	op38,
+	op39,
+	op40,
+	op41,
+	op42,
+	op43,
+	op44,
+	op45,
+	op46,
+	op47,
+	op48,
+	op49,
+	op50,
+	op51,
+	op52,
+	op53,
+	op54,
+	op55,
+	op56,
+	op57,
+	op58,
+};
+int tempregs[] = { 0, 1, 2, 4, 5, 8, 9, 10, 11, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, -1 };
+int permregs[] = { 3, 12, 13, 14, 15, -1 };
+bittype validregs[] = {
+	0xffffffff3f,
+};
+static int amap[MAXREGS][NUMCLASS] = {
+	/* 0 */{ 0x1,0x0,0x0 },
+	/* 1 */{ 0x2,0x0,0x0 },
+	/* 2 */{ 0x4,0x0,0x0 },
+	/* 3 */{ 0x8,0x0,0x0 },
+	/* 4 */{ 0x10,0x0,0x0 },
+	/* 5 */{ 0x20,0x0,0x0 },
+	/* 6 */{ 0x0,0x0,0x0 },
+	/* 7 */{ 0x0,0x0,0x0 },
+	/* 8 */{ 0x40,0x0,0x0 },
+	/* 9 */{ 0x80,0x0,0x0 },
+	/* 10 */{ 0x100,0x0,0x0 },
+	/* 11 */{ 0x200,0x0,0x0 },
+	/* 12 */{ 0x400,0x0,0x0 },
+	/* 13 */{ 0x800,0x0,0x0 },
+	/* 14 */{ 0x1000,0x0,0x0 },
+	/* 15 */{ 0x2000,0x0,0x0 },
+	/* 16 */{ 0x0,0x1,0x0 },
+	/* 17 */{ 0x0,0x2,0x0 },
+	/* 18 */{ 0x0,0x4,0x0 },
+	/* 19 */{ 0x0,0x8,0x0 },
+	/* 20 */{ 0x0,0x10,0x0 },
+	/* 21 */{ 0x0,0x20,0x0 },
+	/* 22 */{ 0x0,0x40,0x0 },
+	/* 23 */{ 0x0,0x80,0x0 },
+	/* 24 */{ 0x0,0x100,0x0 },
+	/* 25 */{ 0x0,0x200,0x0 },
+	/* 26 */{ 0x0,0x400,0x0 },
+	/* 27 */{ 0x0,0x800,0x0 },
+	/* 28 */{ 0x0,0x1000,0x0 },
+	/* 29 */{ 0x0,0x2000,0x0 },
+	/* 30 */{ 0x0,0x4000,0x0 },
+	/* 31 */{ 0x0,0x8000,0x0 },
+	/* 32 */{ 0x0,0x0,0x1 },
+	/* 33 */{ 0x0,0x0,0x2 },
+	/* 34 */{ 0x0,0x0,0x4 },
+	/* 35 */{ 0x0,0x0,0x8 },
+	/* 36 */{ 0x0,0x0,0x10 },
+	/* 37 */{ 0x0,0x0,0x20 },
+	/* 38 */{ 0x0,0x0,0x40 },
+	/* 39 */{ 0x0,0x0,0x80 },
+};
+int
+aliasmap(int class, int regnum)
+{
+	return amap[regnum][class-1];
+}
+static int rmap[NUMCLASS][16] = {
+	{ 0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, },
+	{ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, },
+	{ 32, 33, 34, 35, 36, 37, 38, 39, },
+};
+
+int
+color2reg(int color, int class)
+{
+	return rmap[class-1][color];
+}
+int regK[] = { 0, 14, 16, 8, 0, 0, 0, 0 };
+int
+classmask(int class)
+{
+	if(class == CLASSA) return 0x3fff;
+	if(class == CLASSB) return 0xffff;
+	if(class == CLASSC) return 0xff;
+	if(class == CLASSD) return 0x0;
+	if(class == CLASSE) return 0x0;
+	if(class == CLASSF) return 0x0;
+	return 0x0;
+}
+static bittype ovlarr[MAXREGS][1] = {
+{ 0x1,  },
+{ 0x2,  },
+{ 0x4,  },
+{ 0x8,  },
+{ 0x10,  },
+{ 0x20,  },
+{ 0x40,  },
+{ 0x80,  },
+{ 0x100,  },
+{ 0x200,  },
+{ 0x400,  },
+{ 0x800,  },
+{ 0x1000,  },
+{ 0x2000,  },
+{ 0x4000,  },
+{ 0x8000,  },
+{ 0x10000,  },
+{ 0x20000,  },
+{ 0x40000,  },
+{ 0x80000,  },
+{ 0x100000,  },
+{ 0x200000,  },
+{ 0x400000,  },
+{ 0x800000,  },
+{ 0x1000000,  },
+{ 0x2000000,  },
+{ 0x4000000,  },
+{ 0x8000000,  },
+{ 0x10000000,  },
+{ 0x20000000,  },
+{ 0x40000000,  },
+{ 0x80000000,  },
+{ 0x1,  },
+{ 0x2,  },
+{ 0x4,  },
+{ 0x8,  },
+{ 0x10,  },
+{ 0x20,  },
+{ 0x40,  },
+{ 0x80,  },
+};
+int
+interferes(int reg1, int reg2)
+{
+return (TESTBIT(ovlarr[reg1], reg2)) != 0;
+}
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/amd64/external.h pcc/cc/ccom/arch/amd64/external.h
--- pcc-1.0.0/cc/ccom/arch/amd64/external.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/amd64/external.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,35 @@
+#ifndef _EXTERNAL_H_
+#define _EXTERNAL_H_
+#define NEED_SMULLL
+#define NEED_SDIVLL
+#define NEED_SMODLL
+#define NEED_SPLUSLL
+#define NEED_SMINUSLL
+#define NEED_UMULLL
+#define NEED_UDIVLL
+#define NEED_UMODLL
+#define NEED_UPLUSLL
+#define NEED_UMINUSLL
+#define MAXOPLEN 48
+#define NUMBITS 64
+#define BIT2BYTE(bits) ((((bits)+NUMBITS-1)/NUMBITS)*(NUMBITS/8))
+#define BITSET(arr, bit) (arr[bit/NUMBITS] |= ((long)1 << (bit & (NUMBITS-1))))
+#define BITCLEAR(arr, bit) (arr[bit/NUMBITS] &= ~((long)1 << (bit & (NUMBITS-1))))
+#define TESTBIT(arr, bit) (arr[bit/NUMBITS] & ((long)1 << (bit & (NUMBITS-1))))
+typedef long bittype;
+extern int tempregs[], permregs[];
+#define NTEMPREG 26
+#define FREGS 25
+#define NPERMREG 6
+extern bittype validregs[];
+#define AREGCNT 14
+#define BREGCNT 16
+#define CREGCNT 8
+#define DREGCNT 0
+#define EREGCNT 0
+#define FREGCNT 0
+#define GREGCNT 0
+int aliasmap(int class, int regnum);
+int color2reg(int color, int class);
+int interferes(int reg1, int reg2);
+#endif /* _EXTERNAL_H_ */
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/arm32/external.c pcc/cc/ccom/arch/arm32/external.c
--- pcc-1.0.0/cc/ccom/arch/arm32/external.c	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/arm32/external.c	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,246 @@
+#include "pass2.h"
+
+// TODO: replace with file generated by ccom_mkext
+
+static int op0[] = { -1 };
+static int op1[] = { -1 };
+static int op2[] = { -1 };
+static int op3[] = { -1 };
+static int op4[] = { -1 };
+static int op5[] = { -1 };
+static int op6[] = { -1 };
+static int op7[] = { -1 };
+static int op8[] = { -1 };
+static int op9[] = { -1 };
+static int op10[] = { -1 };
+static int op11[] = { -1 };
+static int op12[] = { -1 };
+static int op13[] = { -1 };
+static int op14[] = { -1 };
+static int op15[] = { -1 };
+static int op16[] = { -1 };
+static int op17[] = { -1 };
+static int op18[] = { -1 };
+static int op19[] = { -1 };
+static int op20[] = { -1 };
+static int op21[] = { -1 };
+static int op22[] = { -1 };
+static int op23[] = { -1 };
+static int op24[] = { -1 };
+static int op25[] = { -1 };
+static int op26[] = { -1 };
+static int op27[] = { -1 };
+static int op28[] = { -1 };
+static int op29[] = { -1 };
+static int op30[] = { -1 };
+static int op31[] = { -1 };
+static int op32[] = { -1 };
+static int op33[] = { -1 };
+static int op34[] = { -1 };
+static int op35[] = { -1 };
+static int op36[] = { -1 };
+static int op37[] = { -1 };
+static int op38[] = { -1 };
+static int op39[] = { -1 };
+static int op40[] = { -1 };
+static int op41[] = { -1 };
+static int op42[] = { -1 };
+static int op43[] = { -1 };
+static int op44[] = { -1 };
+static int op45[] = { -1 };
+static int op46[] = { -1 };
+static int op47[] = { -1 };
+static int op48[] = { -1 };
+static int op49[] = { -1 };
+static int op50[] = { -1 };
+static int op51[] = { -1 };
+static int op52[] = { -1 };
+static int op53[] = { -1 };
+static int op54[] = { -1 };
+static int op55[] = { -1 };
+static int op56[] = { -1 };
+static int op57[] = { -1 };
+static int op58[] = { -1 };
+
+int *qtable[] = { 
+	op0,
+	op1,
+	op2,
+	op3,
+	op4,
+	op5,
+	op6,
+	op7,
+	op8,
+	op9,
+	op10,
+	op11,
+	op12,
+	op13,
+	op14,
+	op15,
+	op16,
+	op17,
+	op18,
+	op19,
+	op20,
+	op21,
+	op22,
+	op23,
+	op24,
+	op25,
+	op26,
+	op27,
+	op28,
+	op29,
+	op30,
+	op31,
+	op32,
+	op33,
+	op34,
+	op35,
+	op36,
+	op37,
+	op38,
+	op39,
+	op40,
+	op41,
+	op42,
+	op43,
+	op44,
+	op45,
+	op46,
+	op47,
+	op48,
+	op49,
+	op50,
+	op51,
+	op52,
+	op53,
+	op54,
+	op55,
+	op56,
+	op57,
+	op58,
+};
+int tempregs[] = { -1 };
+int permregs[] = { -1 };
+bittype validregs[] = {
+	0x7fffffffff,
+};
+static int amap[MAXREGS][NUMCLASS] = {
+	/* 0 */{ 0x0,0x0,0x0,0x0 },
+	/* 1 */{ 0x0,0x0,0x0,0x0 },
+	/* 2 */{ 0x0,0x0,0x0,0x0 },
+	/* 3 */{ 0x0,0x0,0x0,0x0 },
+	/* 4 */{ 0x0,0x0,0x0,0x0 },
+	/* 5 */{ 0x0,0x0,0x0,0x0 },
+	/* 6 */{ 0x0,0x0,0x0,0x0 },
+	/* 7 */{ 0x0,0x0,0x0,0x0 },
+	/* 8 */{ 0x0,0x0,0x0,0x0 },
+	/* 9 */{ 0x0,0x0,0x0,0x0 },
+	/* 10 */{ 0x0,0x0,0x0,0x0 },
+	/* 11 */{ 0x0,0x0,0x0,0x0 },
+	/* 12 */{ 0x0,0x0,0x0,0x0 },
+	/* 13 */{ 0x0,0x0,0x0,0x0 },
+	/* 14 */{ 0x0,0x0,0x0,0x0 },
+	/* 15 */{ 0x0,0x0,0x0,0x0 },
+	/* 16 */{ 0x0,0x0,0x0,0x0 },
+	/* 17 */{ 0x0,0x0,0x0,0x0 },
+	/* 18 */{ 0x0,0x0,0x0,0x0 },
+	/* 19 */{ 0x0,0x0,0x0,0x0 },
+	/* 20 */{ 0x0,0x0,0x0,0x0 },
+	/* 21 */{ 0x0,0x0,0x0,0x0 },
+	/* 22 */{ 0x0,0x0,0x0,0x0 },
+	/* 23 */{ 0x0,0x0,0x0,0x0 },
+	/* 24 */{ 0x0,0x0,0x0,0x0 },
+	/* 25 */{ 0x0,0x0,0x0,0x0 },
+	/* 26 */{ 0x0,0x0,0x0,0x0 },
+	/* 27 */{ 0x0,0x0,0x0,0x0 },
+	/* 28 */{ 0x0,0x0,0x0,0x0 },
+	/* 29 */{ 0x0,0x0,0x0,0x0 },
+	/* 30 */{ 0x0,0x0,0x0,0x0 },
+	/* 31 */{ 0x0,0x0,0x0,0x0 },
+	/* 32 */{ 0x0,0x0,0x0,0x0 },
+	/* 33 */{ 0x0,0x0,0x0,0x0 },
+	/* 34 */{ 0x0,0x0,0x0,0x0 },
+	/* 35 */{ 0x0,0x0,0x0,0x0 },
+	/* 36 */{ 0x0,0x0,0x0,0x0 },
+	/* 37 */{ 0x0,0x0,0x0,0x0 },
+	/* 38 */{ 0x0,0x0,0x0,0x0 }
+};
+int
+aliasmap(int class, int regnum)
+{
+	return amap[regnum][class-1];
+}
+static int rmap[NUMCLASS][15] = {
+	{ 0, 1, 2, 3, 4, 5, },
+	{ 8, 9, 10, 11, 12, 13, 14, 15, },
+	{ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, },
+	{ 31, 32, 33, 34, 35, 36, 37, 38, },
+};
+
+int
+color2reg(int color, int class)
+{
+	return rmap[class-1][color];
+}
+int regK[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+int
+classmask(int class)
+{
+	if(class == CLASSA) return 0x0;
+	if(class == CLASSB) return 0x0;
+	if(class == CLASSC) return 0x0;
+	if(class == CLASSD) return 0x0;
+	if(class == CLASSE) return 0x0;
+	if(class == CLASSF) return 0x0;
+	return 0x0;
+}
+static bittype ovlarr[MAXREGS][1] = {
+{ 0x1f0301,  },
+{ 0x1e10c02,  },
+{ 0xe223004,  },
+{ 0x3244c008,  },
+{ 0x54880010,  },
+{ 0x69100020,  },
+{ 0x40,  },
+{ 0x80,  },
+{ 0x1f0101,  },
+{ 0x1f0201,  },
+{ 0x1e10402,  },
+{ 0x1e10802,  },
+{ 0xe221004,  },
+{ 0xe222004,  },
+{ 0x32444008,  },
+{ 0x32448008,  },
+{ 0x1ff0f03,  },
+{ 0xe3f3305,  },
+{ 0x325fc309,  },
+{ 0x549f0311,  },
+{ 0x691f0321,  },
+{ 0xfe33c06,  },
+{ 0x33e5cc0a,  },
+{ 0x55e90c12,  },
+{ 0x69f10c22,  },
+{ 0x3e66f00c,  },
+{ 0x5eaa3014,  },
+{ 0x6f323024,  },
+{ 0x76ccc018,  },
+{ 0x7b54c028,  },
+{ 0x7d980030,  },
+{ 0x80000000,  },
+{ 0x1,  },
+{ 0x2,  },
+{ 0x4,  },
+{ 0x8,  },
+{ 0x10,  },
+{ 0x20,  },
+{ 0x40,  },
+};
+int
+interferes(int reg1, int reg2)
+{
+return (TESTBIT(ovlarr[reg1], reg2)) != 0;
+}
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/arm32/external.h pcc/cc/ccom/arch/arm32/external.h
--- pcc-1.0.0/cc/ccom/arch/arm32/external.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/arm32/external.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,27 @@
+// TODO: replace with file generated by ccom_mkext
+
+#ifndef _EXTERNAL_H_
+#define _EXTERNAL_H_
+#define MAXOPLEN 0
+#define NUMBITS 32
+#define BIT2BYTE(bits) ((((bits)+NUMBITS-1)/NUMBITS)*(NUMBITS/8))
+#define BITSET(arr, bit) (arr[bit/NUMBITS] |= ((int)1 << (bit & (NUMBITS-1))))
+#define BITCLEAR(arr, bit) (arr[bit/NUMBITS] &= ~((int)1 << (bit & (NUMBITS-1))))
+#define TESTBIT(arr, bit) (arr[bit/NUMBITS] & ((int)1 << (bit & (NUMBITS-1))))
+typedef int bittype;
+extern int tempregs[], permregs[];
+#define NTEMPREG 0
+#define FREGS 0
+#define NPERMREG 0
+extern bittype validregs[];
+#define AREGCNT 0
+#define BREGCNT 0
+#define CREGCNT 0
+#define DREGCNT 0
+#define EREGCNT 0
+#define FREGCNT 0
+#define GREGCNT 0
+int aliasmap(int class, int regnum);
+int color2reg(int color, int class);
+int interferes(int reg1, int reg2);
+#endif /* _EXTERNAL_H_ */
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/ia32/external.c pcc/cc/ccom/arch/ia32/external.c
--- pcc-1.0.0/cc/ccom/arch/ia32/external.c	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/ia32/external.c	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,244 @@
+#include "pass2.h"
+static int op0[] = { -1 };
+static int op1[] = { -1 };
+static int op2[] = { 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 232, 234, -1 };
+static int op3[] = { -1 };
+static int op4[] = { 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 232, 234, -1 };
+static int op5[] = { 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 232, 234, -1 };
+static int op6[] = { 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 232, 234, -1 };
+static int op7[] = { 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 232, 234, -1 };
+static int op8[] = { 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 232, 234, -1 };
+static int op9[] = { 233, 234, -1 };
+static int op10[] = { 68, 69, 70, 71, 72, 73, 74, 75, 76, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 234, -1 };
+static int op11[] = { 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 234, -1 };
+static int op12[] = { 151, 152, 153, 154, 155, 156, 157, 234, -1 };
+static int op13[] = { 158, 159, 160, 161, 162, 234, -1 };
+static int op14[] = { 163, 164, 165, 166, 167, 168, 234, -1 };
+static int op15[] = { 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 183, 184, 185, 186, 187, 188, 189, 234, -1 };
+static int op16[] = { 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 234, -1 };
+static int op17[] = { 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 234, -1 };
+static int op18[] = { 97, 98, 99, 100, 101, 102, 103, 234, -1 };
+static int op19[] = { 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 234, -1 };
+static int op20[] = { 211, 212, 213, 214, 233, 234, -1 };
+static int op21[] = { -1 };
+static int op22[] = { -1 };
+static int op23[] = { 169, 170, 171, 172, 173, 174, 175, 228, 233, 234, -1 };
+static int op24[] = { 206, 207, 208, 209, 210, 233, 234, -1 };
+static int op25[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op26[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op27[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op28[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op29[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op30[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op31[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op32[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op33[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op34[] = { 176, 177, 178, 179, 180, 181, 182, 234, -1 };
+static int op35[] = { 234, -1 };
+static int op36[] = { 231, 233, 234, -1 };
+static int op37[] = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 233, 234, -1 };
+static int op38[] = { 1, 233, 234, -1 };
+static int op39[] = { 234, -1 };
+static int op40[] = { 234, -1 };
+static int op41[] = { 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 234, -1 };
+static int op42[] = { 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 233, 234, -1 };
+static int op43[] = { 234, -1 };
+static int op44[] = { 233, 234, -1 };
+static int op45[] = { 65, 66, 67, 234, -1 };
+static int op46[] = { 62, 63, 64, 233, 234, -1 };
+static int op47[] = { 232, 234, -1 };
+static int op48[] = { 234, -1 };
+static int op49[] = { 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 229, -1 };
+static int op50[] = { 150, 230, -1 };
+static int op51[] = { 227, 233, 234, -1 };
+static int op52[] = { 233, 234, -1 };
+static int op53[] = { 234, -1 };
+static int op54[] = { 190, 191, 233, 234, -1 };
+static int op55[] = { -1 };
+static int op56[] = { 234, -1 };
+static int op57[] = { 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 233, 234, -1 };
+static int op58[] = { 233, 234, -1 };
+
+int *qtable[] = { 
+	op0,
+	op1,
+	op2,
+	op3,
+	op4,
+	op5,
+	op6,
+	op7,
+	op8,
+	op9,
+	op10,
+	op11,
+	op12,
+	op13,
+	op14,
+	op15,
+	op16,
+	op17,
+	op18,
+	op19,
+	op20,
+	op21,
+	op22,
+	op23,
+	op24,
+	op25,
+	op26,
+	op27,
+	op28,
+	op29,
+	op30,
+	op31,
+	op32,
+	op33,
+	op34,
+	op35,
+	op36,
+	op37,
+	op38,
+	op39,
+	op40,
+	op41,
+	op42,
+	op43,
+	op44,
+	op45,
+	op46,
+	op47,
+	op48,
+	op49,
+	op50,
+	op51,
+	op52,
+	op53,
+	op54,
+	op55,
+	op56,
+	op57,
+	op58,
+};
+int tempregs[] = { 0, 1, 2, -1 };
+int permregs[] = { 3, 4, 5, -1 };
+bittype validregs[] = {
+	0xffffff3f,
+	0x0000007f,
+};
+static int amap[MAXREGS][NUMCLASS] = {
+	/* 0 */{ 0x1,0x3,0x1f,0x0 },
+	/* 1 */{ 0x2,0xc,0x1e1,0x0 },
+	/* 2 */{ 0x4,0x30,0xe22,0x0 },
+	/* 3 */{ 0x8,0xc0,0x3244,0x0 },
+	/* 4 */{ 0x10,0x0,0x5488,0x0 },
+	/* 5 */{ 0x20,0x0,0x6910,0x0 },
+	/* 6 */{ 0x0,0x0,0x0,0x0 },
+	/* 7 */{ 0x0,0x0,0x0,0x0 },
+	/* 8 */{ 0x1,0x1,0x1f,0x0 },
+	/* 9 */{ 0x1,0x2,0x1f,0x0 },
+	/* 10 */{ 0x2,0x4,0x1e1,0x0 },
+	/* 11 */{ 0x2,0x8,0x1e1,0x0 },
+	/* 12 */{ 0x4,0x10,0xe22,0x0 },
+	/* 13 */{ 0x4,0x20,0xe22,0x0 },
+	/* 14 */{ 0x8,0x40,0x3244,0x0 },
+	/* 15 */{ 0x8,0x80,0x3244,0x0 },
+	/* 16 */{ 0x3,0xf,0x1ff,0x0 },
+	/* 17 */{ 0x5,0x33,0xe3f,0x0 },
+	/* 18 */{ 0x9,0xc3,0x325f,0x0 },
+	/* 19 */{ 0x11,0x3,0x549f,0x0 },
+	/* 20 */{ 0x21,0x3,0x691f,0x0 },
+	/* 21 */{ 0x6,0x3c,0xfe3,0x0 },
+	/* 22 */{ 0xa,0xcc,0x33e5,0x0 },
+	/* 23 */{ 0x12,0xc,0x55e9,0x0 },
+	/* 24 */{ 0x22,0xc,0x69f1,0x0 },
+	/* 25 */{ 0xc,0xf0,0x3e66,0x0 },
+	/* 26 */{ 0x14,0x30,0x5eaa,0x0 },
+	/* 27 */{ 0x24,0x30,0x6f32,0x0 },
+	/* 28 */{ 0x18,0xc0,0x76cc,0x0 },
+	/* 29 */{ 0x28,0xc0,0x7b54,0x0 },
+	/* 30 */{ 0x30,0x0,0x7d98,0x0 },
+	/* 31 */{ 0x0,0x0,0x0,0x1 },
+	/* 32 */{ 0x0,0x0,0x0,0x2 },
+	/* 33 */{ 0x0,0x0,0x0,0x4 },
+	/* 34 */{ 0x0,0x0,0x0,0x8 },
+	/* 35 */{ 0x0,0x0,0x0,0x10 },
+	/* 36 */{ 0x0,0x0,0x0,0x20 },
+	/* 37 */{ 0x0,0x0,0x0,0x40 },
+	/* 38 */{ 0x0,0x0,0x0,0x80 },
+};
+int
+aliasmap(int class, int regnum)
+{
+	return amap[regnum][class-1];
+}
+static int rmap[NUMCLASS][15] = {
+	{ 0, 1, 2, 3, 4, 5, },
+	{ 8, 9, 10, 11, 12, 13, 14, 15, },
+	{ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, },
+	{ 31, 32, 33, 34, 35, 36, 37, 38, },
+};
+
+int
+color2reg(int color, int class)
+{
+	return rmap[class-1][color];
+}
+int regK[] = { 0, 6, 8, 15, 8, 0, 0, 0 };
+int
+classmask(int class)
+{
+	if(class == CLASSA) return 0x3f;
+	if(class == CLASSB) return 0xff;
+	if(class == CLASSC) return 0x7fff;
+	if(class == CLASSD) return 0xff;
+	if(class == CLASSE) return 0x0;
+	if(class == CLASSF) return 0x0;
+	return 0x0;
+}
+static bittype ovlarr[MAXREGS][2] = {
+{ 0x1f0301, 0x0,  },
+{ 0x1e10c02, 0x0,  },
+{ 0xe223004, 0x0,  },
+{ 0x3244c008, 0x0,  },
+{ 0x54880010, 0x0,  },
+{ 0x69100020, 0x0,  },
+{ 0x40, 0x0,  },
+{ 0x80, 0x0,  },
+{ 0x1f0101, 0x0,  },
+{ 0x1f0201, 0x0,  },
+{ 0x1e10402, 0x0,  },
+{ 0x1e10802, 0x0,  },
+{ 0xe221004, 0x0,  },
+{ 0xe222004, 0x0,  },
+{ 0x32444008, 0x0,  },
+{ 0x32448008, 0x0,  },
+{ 0x1ff0f03, 0x0,  },
+{ 0xe3f3305, 0x0,  },
+{ 0x325fc309, 0x0,  },
+{ 0x549f0311, 0x0,  },
+{ 0x691f0321, 0x0,  },
+{ 0xfe33c06, 0x0,  },
+{ 0x33e5cc0a, 0x0,  },
+{ 0x55e90c12, 0x0,  },
+{ 0x69f10c22, 0x0,  },
+{ 0x3e66f00c, 0x0,  },
+{ 0x5eaa3014, 0x0,  },
+{ 0x6f323024, 0x0,  },
+{ 0x76ccc018, 0x0,  },
+{ 0x7b54c028, 0x0,  },
+{ 0x7d980030, 0x0,  },
+{ 0x80000000, 0x0,  },
+{ 0x0, 0x1,  },
+{ 0x0, 0x2,  },
+{ 0x0, 0x4,  },
+{ 0x0, 0x8,  },
+{ 0x0, 0x10,  },
+{ 0x0, 0x20,  },
+{ 0x0, 0x40,  },
+};
+int
+interferes(int reg1, int reg2)
+{
+return (TESTBIT(ovlarr[reg1], reg2)) != 0;
+}
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/ia32/external.h pcc/cc/ccom/arch/ia32/external.h
--- pcc-1.0.0/cc/ccom/arch/ia32/external.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/ia32/external.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,25 @@
+#ifndef _EXTERNAL_H_
+#define _EXTERNAL_H_
+#define MAXOPLEN 42
+#define NUMBITS 32
+#define BIT2BYTE(bits) ((((bits)+NUMBITS-1)/NUMBITS)*(NUMBITS/8))
+#define BITSET(arr, bit) (arr[bit/NUMBITS] |= ((int)1 << (bit & (NUMBITS-1))))
+#define BITCLEAR(arr, bit) (arr[bit/NUMBITS] &= ~((int)1 << (bit & (NUMBITS-1))))
+#define TESTBIT(arr, bit) (arr[bit/NUMBITS] & ((int)1 << (bit & (NUMBITS-1))))
+typedef int bittype;
+extern int tempregs[], permregs[];
+#define NTEMPREG 4
+#define FREGS 3
+#define NPERMREG 4
+extern bittype validregs[];
+#define AREGCNT 6
+#define BREGCNT 8
+#define CREGCNT 15
+#define DREGCNT 8
+#define EREGCNT 0
+#define FREGCNT 0
+#define GREGCNT 0
+int aliasmap(int class, int regnum);
+int color2reg(int color, int class);
+int interferes(int reg1, int reg2);
+#endif /* _EXTERNAL_H_ */
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/mips32/external.c pcc/cc/ccom/arch/mips32/external.c
--- pcc-1.0.0/cc/ccom/arch/mips32/external.c	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/mips32/external.c	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,246 @@
+#include "pass2.h"
+
+// TODO: replace with file generated by ccom_mkext
+
+static int op0[] = { -1 };
+static int op1[] = { -1 };
+static int op2[] = { -1 };
+static int op3[] = { -1 };
+static int op4[] = { -1 };
+static int op5[] = { -1 };
+static int op6[] = { -1 };
+static int op7[] = { -1 };
+static int op8[] = { -1 };
+static int op9[] = { -1 };
+static int op10[] = { -1 };
+static int op11[] = { -1 };
+static int op12[] = { -1 };
+static int op13[] = { -1 };
+static int op14[] = { -1 };
+static int op15[] = { -1 };
+static int op16[] = { -1 };
+static int op17[] = { -1 };
+static int op18[] = { -1 };
+static int op19[] = { -1 };
+static int op20[] = { -1 };
+static int op21[] = { -1 };
+static int op22[] = { -1 };
+static int op23[] = { -1 };
+static int op24[] = { -1 };
+static int op25[] = { -1 };
+static int op26[] = { -1 };
+static int op27[] = { -1 };
+static int op28[] = { -1 };
+static int op29[] = { -1 };
+static int op30[] = { -1 };
+static int op31[] = { -1 };
+static int op32[] = { -1 };
+static int op33[] = { -1 };
+static int op34[] = { -1 };
+static int op35[] = { -1 };
+static int op36[] = { -1 };
+static int op37[] = { -1 };
+static int op38[] = { -1 };
+static int op39[] = { -1 };
+static int op40[] = { -1 };
+static int op41[] = { -1 };
+static int op42[] = { -1 };
+static int op43[] = { -1 };
+static int op44[] = { -1 };
+static int op45[] = { -1 };
+static int op46[] = { -1 };
+static int op47[] = { -1 };
+static int op48[] = { -1 };
+static int op49[] = { -1 };
+static int op50[] = { -1 };
+static int op51[] = { -1 };
+static int op52[] = { -1 };
+static int op53[] = { -1 };
+static int op54[] = { -1 };
+static int op55[] = { -1 };
+static int op56[] = { -1 };
+static int op57[] = { -1 };
+static int op58[] = { -1 };
+
+int *qtable[] = { 
+	op0,
+	op1,
+	op2,
+	op3,
+	op4,
+	op5,
+	op6,
+	op7,
+	op8,
+	op9,
+	op10,
+	op11,
+	op12,
+	op13,
+	op14,
+	op15,
+	op16,
+	op17,
+	op18,
+	op19,
+	op20,
+	op21,
+	op22,
+	op23,
+	op24,
+	op25,
+	op26,
+	op27,
+	op28,
+	op29,
+	op30,
+	op31,
+	op32,
+	op33,
+	op34,
+	op35,
+	op36,
+	op37,
+	op38,
+	op39,
+	op40,
+	op41,
+	op42,
+	op43,
+	op44,
+	op45,
+	op46,
+	op47,
+	op48,
+	op49,
+	op50,
+	op51,
+	op52,
+	op53,
+	op54,
+	op55,
+	op56,
+	op57,
+	op58,
+};
+int tempregs[] = { -1 };
+int permregs[] = { -1 };
+bittype validregs[] = {
+	0x7fffffffff,
+};
+static int amap[MAXREGS][NUMCLASS] = {
+	/* 0 */{ 0x0,0x0,0x0,0x0 },
+	/* 1 */{ 0x0,0x0,0x0,0x0 },
+	/* 2 */{ 0x0,0x0,0x0,0x0 },
+	/* 3 */{ 0x0,0x0,0x0,0x0 },
+	/* 4 */{ 0x0,0x0,0x0,0x0 },
+	/* 5 */{ 0x0,0x0,0x0,0x0 },
+	/* 6 */{ 0x0,0x0,0x0,0x0 },
+	/* 7 */{ 0x0,0x0,0x0,0x0 },
+	/* 8 */{ 0x0,0x0,0x0,0x0 },
+	/* 9 */{ 0x0,0x0,0x0,0x0 },
+	/* 10 */{ 0x0,0x0,0x0,0x0 },
+	/* 11 */{ 0x0,0x0,0x0,0x0 },
+	/* 12 */{ 0x0,0x0,0x0,0x0 },
+	/* 13 */{ 0x0,0x0,0x0,0x0 },
+	/* 14 */{ 0x0,0x0,0x0,0x0 },
+	/* 15 */{ 0x0,0x0,0x0,0x0 },
+	/* 16 */{ 0x0,0x0,0x0,0x0 },
+	/* 17 */{ 0x0,0x0,0x0,0x0 },
+	/* 18 */{ 0x0,0x0,0x0,0x0 },
+	/* 19 */{ 0x0,0x0,0x0,0x0 },
+	/* 20 */{ 0x0,0x0,0x0,0x0 },
+	/* 21 */{ 0x0,0x0,0x0,0x0 },
+	/* 22 */{ 0x0,0x0,0x0,0x0 },
+	/* 23 */{ 0x0,0x0,0x0,0x0 },
+	/* 24 */{ 0x0,0x0,0x0,0x0 },
+	/* 25 */{ 0x0,0x0,0x0,0x0 },
+	/* 26 */{ 0x0,0x0,0x0,0x0 },
+	/* 27 */{ 0x0,0x0,0x0,0x0 },
+	/* 28 */{ 0x0,0x0,0x0,0x0 },
+	/* 29 */{ 0x0,0x0,0x0,0x0 },
+	/* 30 */{ 0x0,0x0,0x0,0x0 },
+	/* 31 */{ 0x0,0x0,0x0,0x0 },
+	/* 32 */{ 0x0,0x0,0x0,0x0 },
+	/* 33 */{ 0x0,0x0,0x0,0x0 },
+	/* 34 */{ 0x0,0x0,0x0,0x0 },
+	/* 35 */{ 0x0,0x0,0x0,0x0 },
+	/* 36 */{ 0x0,0x0,0x0,0x0 },
+	/* 37 */{ 0x0,0x0,0x0,0x0 },
+	/* 38 */{ 0x0,0x0,0x0,0x0 }
+};
+int
+aliasmap(int class, int regnum)
+{
+	return amap[regnum][class-1];
+}
+static int rmap[NUMCLASS][15] = {
+	{ 0, 1, 2, 3, 4, 5, },
+	{ 8, 9, 10, 11, 12, 13, 14, 15, },
+	{ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, },
+	{ 31, 32, 33, 34, 35, 36, 37, 38, },
+};
+
+int
+color2reg(int color, int class)
+{
+	return rmap[class-1][color];
+}
+int regK[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+int
+classmask(int class)
+{
+	if(class == CLASSA) return 0x0;
+	if(class == CLASSB) return 0x0;
+	if(class == CLASSC) return 0x0;
+	if(class == CLASSD) return 0x0;
+	if(class == CLASSE) return 0x0;
+	if(class == CLASSF) return 0x0;
+	return 0x0;
+}
+static bittype ovlarr[MAXREGS][1] = {
+{ 0x1f0301,  },
+{ 0x1e10c02,  },
+{ 0xe223004,  },
+{ 0x3244c008,  },
+{ 0x54880010,  },
+{ 0x69100020,  },
+{ 0x40,  },
+{ 0x80,  },
+{ 0x1f0101,  },
+{ 0x1f0201,  },
+{ 0x1e10402,  },
+{ 0x1e10802,  },
+{ 0xe221004,  },
+{ 0xe222004,  },
+{ 0x32444008,  },
+{ 0x32448008,  },
+{ 0x1ff0f03,  },
+{ 0xe3f3305,  },
+{ 0x325fc309,  },
+{ 0x549f0311,  },
+{ 0x691f0321,  },
+{ 0xfe33c06,  },
+{ 0x33e5cc0a,  },
+{ 0x55e90c12,  },
+{ 0x69f10c22,  },
+{ 0x3e66f00c,  },
+{ 0x5eaa3014,  },
+{ 0x6f323024,  },
+{ 0x76ccc018,  },
+{ 0x7b54c028,  },
+{ 0x7d980030,  },
+{ 0x80000000,  },
+{ 0x1,  },
+{ 0x2,  },
+{ 0x4,  },
+{ 0x8,  },
+{ 0x10,  },
+{ 0x20,  },
+{ 0x40,  },
+};
+int
+interferes(int reg1, int reg2)
+{
+return (TESTBIT(ovlarr[reg1], reg2)) != 0;
+}
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/mips32/external.h pcc/cc/ccom/arch/mips32/external.h
--- pcc-1.0.0/cc/ccom/arch/mips32/external.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/mips32/external.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,27 @@
+// TODO: replace with file generated by ccom_mkext
+
+#ifndef _EXTERNAL_H_
+#define _EXTERNAL_H_
+#define MAXOPLEN 0
+#define NUMBITS 32
+#define BIT2BYTE(bits) ((((bits)+NUMBITS-1)/NUMBITS)*(NUMBITS/8))
+#define BITSET(arr, bit) (arr[bit/NUMBITS] |= ((int)1 << (bit & (NUMBITS-1))))
+#define BITCLEAR(arr, bit) (arr[bit/NUMBITS] &= ~((int)1 << (bit & (NUMBITS-1))))
+#define TESTBIT(arr, bit) (arr[bit/NUMBITS] & ((int)1 << (bit & (NUMBITS-1))))
+typedef int bittype;
+extern int tempregs[], permregs[];
+#define NTEMPREG 0
+#define FREGS 0
+#define NPERMREG 0
+extern bittype validregs[];
+#define AREGCNT 0
+#define BREGCNT 0
+#define CREGCNT 0
+#define DREGCNT 0
+#define EREGCNT 0
+#define FREGCNT 0
+#define GREGCNT 0
+int aliasmap(int class, int regnum);
+int color2reg(int color, int class);
+int interferes(int reg1, int reg2);
+#endif /* _EXTERNAL_H_ */
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/ppc32/external.c pcc/cc/ccom/arch/ppc32/external.c
--- pcc-1.0.0/cc/ccom/arch/ppc32/external.c	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/ppc32/external.c	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,246 @@
+#include "pass2.h"
+
+// TODO: replace with file generated by ccom_mkext
+
+static int op0[] = { -1 };
+static int op1[] = { -1 };
+static int op2[] = { -1 };
+static int op3[] = { -1 };
+static int op4[] = { -1 };
+static int op5[] = { -1 };
+static int op6[] = { -1 };
+static int op7[] = { -1 };
+static int op8[] = { -1 };
+static int op9[] = { -1 };
+static int op10[] = { -1 };
+static int op11[] = { -1 };
+static int op12[] = { -1 };
+static int op13[] = { -1 };
+static int op14[] = { -1 };
+static int op15[] = { -1 };
+static int op16[] = { -1 };
+static int op17[] = { -1 };
+static int op18[] = { -1 };
+static int op19[] = { -1 };
+static int op20[] = { -1 };
+static int op21[] = { -1 };
+static int op22[] = { -1 };
+static int op23[] = { -1 };
+static int op24[] = { -1 };
+static int op25[] = { -1 };
+static int op26[] = { -1 };
+static int op27[] = { -1 };
+static int op28[] = { -1 };
+static int op29[] = { -1 };
+static int op30[] = { -1 };
+static int op31[] = { -1 };
+static int op32[] = { -1 };
+static int op33[] = { -1 };
+static int op34[] = { -1 };
+static int op35[] = { -1 };
+static int op36[] = { -1 };
+static int op37[] = { -1 };
+static int op38[] = { -1 };
+static int op39[] = { -1 };
+static int op40[] = { -1 };
+static int op41[] = { -1 };
+static int op42[] = { -1 };
+static int op43[] = { -1 };
+static int op44[] = { -1 };
+static int op45[] = { -1 };
+static int op46[] = { -1 };
+static int op47[] = { -1 };
+static int op48[] = { -1 };
+static int op49[] = { -1 };
+static int op50[] = { -1 };
+static int op51[] = { -1 };
+static int op52[] = { -1 };
+static int op53[] = { -1 };
+static int op54[] = { -1 };
+static int op55[] = { -1 };
+static int op56[] = { -1 };
+static int op57[] = { -1 };
+static int op58[] = { -1 };
+
+int *qtable[] = { 
+	op0,
+	op1,
+	op2,
+	op3,
+	op4,
+	op5,
+	op6,
+	op7,
+	op8,
+	op9,
+	op10,
+	op11,
+	op12,
+	op13,
+	op14,
+	op15,
+	op16,
+	op17,
+	op18,
+	op19,
+	op20,
+	op21,
+	op22,
+	op23,
+	op24,
+	op25,
+	op26,
+	op27,
+	op28,
+	op29,
+	op30,
+	op31,
+	op32,
+	op33,
+	op34,
+	op35,
+	op36,
+	op37,
+	op38,
+	op39,
+	op40,
+	op41,
+	op42,
+	op43,
+	op44,
+	op45,
+	op46,
+	op47,
+	op48,
+	op49,
+	op50,
+	op51,
+	op52,
+	op53,
+	op54,
+	op55,
+	op56,
+	op57,
+	op58,
+};
+int tempregs[] = { -1 };
+int permregs[] = { -1 };
+bittype validregs[] = {
+	0x7fffffffff,
+};
+static int amap[MAXREGS][NUMCLASS] = {
+	/* 0 */{ 0x0,0x0,0x0,0x0 },
+	/* 1 */{ 0x0,0x0,0x0,0x0 },
+	/* 2 */{ 0x0,0x0,0x0,0x0 },
+	/* 3 */{ 0x0,0x0,0x0,0x0 },
+	/* 4 */{ 0x0,0x0,0x0,0x0 },
+	/* 5 */{ 0x0,0x0,0x0,0x0 },
+	/* 6 */{ 0x0,0x0,0x0,0x0 },
+	/* 7 */{ 0x0,0x0,0x0,0x0 },
+	/* 8 */{ 0x0,0x0,0x0,0x0 },
+	/* 9 */{ 0x0,0x0,0x0,0x0 },
+	/* 10 */{ 0x0,0x0,0x0,0x0 },
+	/* 11 */{ 0x0,0x0,0x0,0x0 },
+	/* 12 */{ 0x0,0x0,0x0,0x0 },
+	/* 13 */{ 0x0,0x0,0x0,0x0 },
+	/* 14 */{ 0x0,0x0,0x0,0x0 },
+	/* 15 */{ 0x0,0x0,0x0,0x0 },
+	/* 16 */{ 0x0,0x0,0x0,0x0 },
+	/* 17 */{ 0x0,0x0,0x0,0x0 },
+	/* 18 */{ 0x0,0x0,0x0,0x0 },
+	/* 19 */{ 0x0,0x0,0x0,0x0 },
+	/* 20 */{ 0x0,0x0,0x0,0x0 },
+	/* 21 */{ 0x0,0x0,0x0,0x0 },
+	/* 22 */{ 0x0,0x0,0x0,0x0 },
+	/* 23 */{ 0x0,0x0,0x0,0x0 },
+	/* 24 */{ 0x0,0x0,0x0,0x0 },
+	/* 25 */{ 0x0,0x0,0x0,0x0 },
+	/* 26 */{ 0x0,0x0,0x0,0x0 },
+	/* 27 */{ 0x0,0x0,0x0,0x0 },
+	/* 28 */{ 0x0,0x0,0x0,0x0 },
+	/* 29 */{ 0x0,0x0,0x0,0x0 },
+	/* 30 */{ 0x0,0x0,0x0,0x0 },
+	/* 31 */{ 0x0,0x0,0x0,0x0 },
+	/* 32 */{ 0x0,0x0,0x0,0x0 },
+	/* 33 */{ 0x0,0x0,0x0,0x0 },
+	/* 34 */{ 0x0,0x0,0x0,0x0 },
+	/* 35 */{ 0x0,0x0,0x0,0x0 },
+	/* 36 */{ 0x0,0x0,0x0,0x0 },
+	/* 37 */{ 0x0,0x0,0x0,0x0 },
+	/* 38 */{ 0x0,0x0,0x0,0x0 }
+};
+int
+aliasmap(int class, int regnum)
+{
+	return amap[regnum][class-1];
+}
+static int rmap[NUMCLASS][15] = {
+	{ 0, 1, 2, 3, 4, 5, },
+	{ 8, 9, 10, 11, 12, 13, 14, 15, },
+	{ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, },
+	{ 31, 32, 33, 34, 35, 36, 37, 38, },
+};
+
+int
+color2reg(int color, int class)
+{
+	return rmap[class-1][color];
+}
+int regK[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+int
+classmask(int class)
+{
+	if(class == CLASSA) return 0x0;
+	if(class == CLASSB) return 0x0;
+	if(class == CLASSC) return 0x0;
+	if(class == CLASSD) return 0x0;
+	if(class == CLASSE) return 0x0;
+	if(class == CLASSF) return 0x0;
+	return 0x0;
+}
+static bittype ovlarr[MAXREGS][1] = {
+{ 0x1f0301,  },
+{ 0x1e10c02,  },
+{ 0xe223004,  },
+{ 0x3244c008,  },
+{ 0x54880010,  },
+{ 0x69100020,  },
+{ 0x40,  },
+{ 0x80,  },
+{ 0x1f0101,  },
+{ 0x1f0201,  },
+{ 0x1e10402,  },
+{ 0x1e10802,  },
+{ 0xe221004,  },
+{ 0xe222004,  },
+{ 0x32444008,  },
+{ 0x32448008,  },
+{ 0x1ff0f03,  },
+{ 0xe3f3305,  },
+{ 0x325fc309,  },
+{ 0x549f0311,  },
+{ 0x691f0321,  },
+{ 0xfe33c06,  },
+{ 0x33e5cc0a,  },
+{ 0x55e90c12,  },
+{ 0x69f10c22,  },
+{ 0x3e66f00c,  },
+{ 0x5eaa3014,  },
+{ 0x6f323024,  },
+{ 0x76ccc018,  },
+{ 0x7b54c028,  },
+{ 0x7d980030,  },
+{ 0x80000000,  },
+{ 0x1,  },
+{ 0x2,  },
+{ 0x4,  },
+{ 0x8,  },
+{ 0x10,  },
+{ 0x20,  },
+{ 0x40,  },
+};
+int
+interferes(int reg1, int reg2)
+{
+return (TESTBIT(ovlarr[reg1], reg2)) != 0;
+}
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/arch/ppc32/external.h pcc/cc/ccom/arch/ppc32/external.h
--- pcc-1.0.0/cc/ccom/arch/ppc32/external.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/arch/ppc32/external.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,27 @@
+// TODO: replace with file generated by ccom_mkext
+
+#ifndef _EXTERNAL_H_
+#define _EXTERNAL_H_
+#define MAXOPLEN 0
+#define NUMBITS 32
+#define BIT2BYTE(bits) ((((bits)+NUMBITS-1)/NUMBITS)*(NUMBITS/8))
+#define BITSET(arr, bit) (arr[bit/NUMBITS] |= ((int)1 << (bit & (NUMBITS-1))))
+#define BITCLEAR(arr, bit) (arr[bit/NUMBITS] &= ~((int)1 << (bit & (NUMBITS-1))))
+#define TESTBIT(arr, bit) (arr[bit/NUMBITS] & ((int)1 << (bit & (NUMBITS-1))))
+typedef int bittype;
+extern int tempregs[], permregs[];
+#define NTEMPREG 0
+#define FREGS 0
+#define NPERMREG 0
+extern bittype validregs[];
+#define AREGCNT 0
+#define BREGCNT 0
+#define CREGCNT 0
+#define DREGCNT 0
+#define EREGCNT 0
+#define FREGCNT 0
+#define GREGCNT 0
+int aliasmap(int class, int regnum);
+int color2reg(int color, int class);
+int interferes(int reg1, int reg2);
+#endif /* _EXTERNAL_H_ */
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/main.c pcc/cc/ccom/main.c
--- pcc-1.0.0/cc/ccom/main.c	2011-01-22 23:08:23.000000000 +0100
+++ pcc/cc/ccom/main.c	2013-09-11 19:46:33.156788000 +0200
@@ -299,6 +299,9 @@
 				perror(NULL);
 				exit(1);
 			}
+		} else {
+			fprintf(stderr, "Reading from standard input is disabled on HelenOS\n");
+			exit(1);
 		}
 		if (argc > 1 && strcmp(argv[1], "-") != 0) {
 			if (freopen(argv[1], "w", stdout) == NULL) {
@@ -310,7 +313,9 @@
 		}
 
 	mkdope();
+#ifndef __helenos__
 	signal(SIGSEGV, segvcatch);
+#endif
 #ifdef SIGBUS
 	signal(SIGBUS, segvcatch);
 #endif
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/Makefile pcc/cc/ccom/Makefile
--- pcc-1.0.0/cc/ccom/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/Makefile	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,94 @@
+#
+# Copyright (c) 2011 Jiri Zarevucky
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# - Redistributions of source code must retain the above copyright
+#   notice, this list of conditions and the following disclaimer.
+# - Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in the
+#   documentation and/or other materials provided with the distribution.
+# - The name of the author may not be used to endorse or promote products
+#   derived from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+MIPDIR = ../../mip
+MDIR = ../../arch/$(PLATFORM)
+OSDIR = ../../os/helenos
+EXTRA_CFLAGS = -I$(MIPDIR) -I$(MDIR) -I$(OSDIR) -I. -w
+DEFS = -Dmach_$(PLATFORM) -D__helenos__ -DPCC_DEBUG -DGCC_COMPAT -Dfree=free
+LIBS = $(LIBSOFTFLOAT_PREFIX)/libsoftfloat.a
+BINARY = ccom
+
+PRE_DEPEND = cgram.c scan.c external.c external.h common.c compat.c
+EXTRA_CLEAN = cgram.c cgram.h scan.c external.c external.h common.c compat.c \
+	$(MIPDIR)/*.o $(MDIR)/*.o
+
+POSIX_COMPAT = y
+
+# FIXME: external.{c,h} must be generated for each target system
+
+SOURCES = \
+	external.c \
+	$(MDIR)/local.c \
+	$(MDIR)/local2.c \
+	$(MDIR)/code.c \
+	$(MDIR)/order.c \
+	$(MDIR)/table.c \
+	$(MIPDIR)/match.c \
+	$(MIPDIR)/reader.c \
+	$(MIPDIR)/optim2.c \
+	$(MIPDIR)/regs.c \
+	common.c \
+	compat.c \
+	cgram.c \
+	scan.c \
+	builtins.c \
+	gcc_compat.c \
+	init.c \
+	inline.c \
+	main.c \
+	optim.c \
+	pftn.c \
+	softfloat.c \
+	stabs.c \
+	symtabs.c \
+	trees.c
+
+include $(USPACE_PREFIX)/Makefile.common
+
+cgram.c: cgram.y
+	$(YACC) $(YFLAGS) -d $<
+	mv y.tab.c cgram.c
+	mv y.tab.h cgram.h
+
+scan.c: scan.l cgram.c
+	$(LEX) $(LFLAGS) $<
+	mv lex.yy.c scan.c
+
+compat.c: $(MIPDIR)/compat.c
+	ln -s -f $^ $@
+
+common.c: $(MIPDIR)/common.c
+	ln -s -f $^ $@
+
+external.c: arch/$(PLATFORM)/external.c
+	ln -s -f $^ $@
+
+external.h: arch/$(PLATFORM)/external.h
+	ln -s -f $^ $@
+
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/mkext/Makefile pcc/cc/ccom/mkext/Makefile
--- pcc-1.0.0/cc/ccom/mkext/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/ccom/mkext/Makefile	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,58 @@
+#
+# Copyright (c) 2011 Jiri Zarevucky
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# - Redistributions of source code must retain the above copyright
+#   notice, this list of conditions and the following disclaimer.
+# - Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in the
+#   documentation and/or other materials provided with the distribution.
+# - The name of the author may not be used to endorse or promote products
+#   derived from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+MIPDIR = ../../../mip
+MDIR = ../../../arch/$(PLATFORM)
+OSDIR = ../../../os/helenos
+EXTRA_CFLAGS = -I$(MIPDIR) -I$(MDIR) -I$(OSDIR) -I. -w
+DEFS = -DGCC_COMPAT -DPCC_DEBUG -DMKEXT -Dmach_$(PLATFORM) -D__helenos__
+BINARY = cc_mkext
+
+POSIX_COMPAT = y
+
+PRE_DEPEND = mkext.c table.c common.c
+EXTRA_CLEAN = mkext.c table.c common.c
+
+# FIXME: external.{c,h} must be generated for each target system
+
+SOURCES = \
+	mkext.c \
+	table.c \
+	common.c
+
+include $(USPACE_PREFIX)/Makefile.common
+
+mkext.c: $(MIPDIR)/mkext.c
+	ln -s -f $^ $@
+
+table.c: $(MDIR)/table.c
+	ln -s -f $^ $@
+
+common.c: $(MIPDIR)/common.c
+	ln -s -f $^ $@
+
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/pftn.c pcc/cc/ccom/pftn.c
--- pcc-1.0.0/cc/ccom/pftn.c	2011-02-20 11:19:07.000000000 +0100
+++ pcc/cc/ccom/pftn.c	2013-09-11 19:46:33.156788000 +0200
@@ -1139,6 +1139,12 @@
 		}
 
 	ap = attr_find(apl, ATTR_BASETYP);
+	
+	if (ap == NULL) {
+		cerror("unknown type");
+		return SZINT;
+	}
+	
 	sz = ap->atypsz;
 	
 #ifdef GCC_COMPAT
diff -ur --unidirectional-new-file pcc-1.0.0/cc/ccom/trees.c pcc/cc/ccom/trees.c
--- pcc-1.0.0/cc/ccom/trees.c	2011-03-01 18:39:28.000000000 +0100
+++ pcc/cc/ccom/trees.c	2013-09-11 19:46:33.156788000 +0200
@@ -72,6 +72,12 @@
 # include <stdarg.h>
 # include <string.h>
 
+/* standard macros conflict with identifiers in this file */
+#ifdef true
+	#undef true
+	#undef false
+#endif
+
 static void chkpun(NODE *p);
 static int opact(NODE *p);
 static int moditype(TWORD);
diff -ur --unidirectional-new-file pcc-1.0.0/cc/cpp/config.h pcc/cc/cpp/config.h
--- pcc-1.0.0/cc/cpp/config.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/cpp/config.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,182 @@
+/* Hard-coded, because wiring up configure script would just not be worth the effort. */
+
+/* Using a.out ABI */
+//#undef AOUTABI
+
+/* Define path to alternate assembler */
+#define ASSEMBLER "/app/as"
+
+/* Using Classic 68k ABI */
+//#undef CLASSIC68K
+
+/* Using COFF ABI */
+//#undef COFFABI
+
+/* Define path to alternate compiler */
+//#undef COMPILER
+
+/* Using ECOFF ABI */
+//#undef ECOFFABI
+
+/* Using ELF ABI */
+#define ELFABI 1
+
+/* Define to 1 if you have the `basename' function. */
+//#define HAVE_BASENAME 1
+
+/* Define to 1 if printf supports C99 size specifiers */
+//#define HAVE_C99_FORMAT 1
+
+/* Define to 1 if your compiler supports C99 variadic macros */
+#define HAVE_CPP_VARARG_MACRO_GCC 1
+
+/* Define to 1 if you have the `ffs' function. */
+#define HAVE_FFS 1
+
+/* Define to 1 if you have the `getopt' function. */
+#define HAVE_GETOPT 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <libgen.h> header file. */
+//#define HAVE_LIBGEN_H 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+//#define HAVE_STRLCAT 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+//#define HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strtold' function. */
+#define HAVE_STRTOLD 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+//#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vfork' function. */
+//#define HAVE_VFORK 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+#ifdef __BE__
+	/* Define if host is BIG endian */
+	#define HOST_BIG_ENDIAN
+	/* Define if target defaults to BIG endian */
+	#undef TARGET_BIG_ENDIAN
+#endif
+
+#ifdef __LE__
+	/* Define if host is LITTLE endian */
+	#define HOST_LITTLE_ENDIAN
+	/* Define if target defaults to LITTLE endian */
+	#define TARGET_LITTLE_ENDIAN
+#endif
+
+/* lex is flex */
+#define ISFLEX 1
+
+/* Define alternate standard lib directory */
+#define LIBDIR "/lib/"
+
+/* Define path to alternate linker */
+#define LINKER "/app/ld"
+
+/* Using Mach-O ABI */
+//#undef MACHOABI
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "<zarevucky.jiri@gmail.com>"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "pcc"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "pcc 1.0.0.RELEASE"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "pcc"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.0.0.RELEASE"
+
+/* Major version no */
+#define PCC_MAJOR 1
+
+/* Minor version no */
+#define PCC_MINOR 0
+
+/* Minor minor version no */
+#define PCC_MINORMINOR 0
+
+/* Using PE/COFF ABI */
+//#undef PECOFFABI
+
+/* Define path to alternate preprocessor */
+#undef PREPROCESSOR
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define alternate standard include directory */
+#define STDINC "/inc/c"
+
+
+/* Target OS */
+#define TARGOS helenos
+
+/* Target OS version */
+#define TARGOSVER 0
+
+/* Enable thread-local storage (TLS). */
+#define TLS 1
+
+/* Version string */
+#define VERSSTR "pcc 1.0.0.RELEASE 20110221 for HelenOS"
+
+/* Size of wide character type */
+#define WCHAR_SIZE 4
+
+/* Type to use for wide characters */
+#define WCHAR_TYPE INT
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+//#define YYTEXT_POINTER 1
+
+#undef COMPILER
+
diff -ur --unidirectional-new-file pcc-1.0.0/cc/cpp/cpp.c pcc/cc/cpp/cpp.c
--- pcc-1.0.0/cc/cpp/cpp.c	2011-03-27 15:17:19.000000000 +0200
+++ pcc/cc/cpp/cpp.c	2013-09-11 19:46:33.156788000 +0200
@@ -274,7 +274,7 @@
 		if ((ofd = open(argv[1], O_WRONLY|O_CREAT, 0600)) < 0)
 			error("Can't creat %s", argv[1]);
 	} else
-		ofd = 1; /* stdout */
+		ofd = fileno(stdout);
 	istty = isatty(ofd);
 
 	if (argc && strcmp(argv[0], "-")) {
@@ -402,7 +402,7 @@
 	struct symtab *nl;
 	usch *osp;
 	usch *fn, *safefn;
-	int c, it;
+	int c;
 
 	if (flslvl)
 		return;
@@ -436,7 +436,7 @@
 			;
 		if (c != '\n')
 			goto bad;
-		it = SYSINC;
+		(void) SYSINC;
 		safefn = fn;
 	} else {
 		usch *nm = stringbuf;
@@ -869,7 +869,6 @@
 {
 	usch *t;
 	usch *sb = stringbuf;
-	int dummy;
 
 	flbuf();
 	savch(0);
@@ -877,8 +876,8 @@
 		t = sheap("%s:%d: warning: ", ifiles->fname, ifiles->lineno);
 		write (2, t, strlen((char *)t));
 	}
-	dummy = write (2, s, strlen((char *)s));
-	dummy = write (2, "\n", 1);
+	write (2, s, strlen((char *)s));
+	write (2, "\n", 1);
 	stringbuf = sb;
 }
 
@@ -886,16 +885,15 @@
 xerror(usch *s)
 {
 	usch *t;
-	int dummy;
 
 	flbuf();
 	savch(0);
 	if (ifiles != NULL) {
 		t = sheap("%s:%d: error: ", ifiles->fname, ifiles->lineno);
-		dummy = write (2, t, strlen((char *)t));
+		write (2, t, strlen((char *)t));
 	}
-	dummy = write (2, s, strlen((char *)s));
-	dummy = write (2, "\n", 1);
+	write (2, s, strlen((char *)s));
+	write (2, "\n", 1);
 	exit(1);
 }
 
@@ -1709,12 +1707,27 @@
 	}
 }
 
+static ssize_t
+_write_all(int fd, const void* buffer, size_t count)
+{
+	size_t remaining = count;
+	while (remaining > 0) {
+		ssize_t retval = write(ofd, buffer, remaining);
+		if (retval < 0) {
+			return retval;
+		}
+		remaining -= retval;
+		buffer += retval;
+	}
+	return count;
+}
+
 void
 flbuf()
 {
 	if (obufp == 0)
 		return;
-	if (Mflag == 0 && write(ofd, outbuf, obufp) < 0)
+	if (Mflag == 0 && _write_all(ofd, outbuf, obufp) < 0)
 		error("obuf write error");
 	lastoch = outbuf[obufp-1];
 	obufp = 0;
@@ -1862,7 +1875,7 @@
 	struct symtab *sp;
 	struct tree *w, *new, *last;
 	int len, cix, bit, fbit, svbit, ix, bitno;
-	const usch *k, *m, *sm;
+	const usch *k, *m;
 
 	/* Count full string length */
 	for (k = key, len = 0; *k; k++, len++)
@@ -1897,7 +1910,7 @@
 
 	sp = (struct symtab *)w;
 
-	sm = m = sp->namep;
+	m = sp->namep;
 	k = key;
 
 	/* Check for correct string and return */
diff -ur --unidirectional-new-file pcc-1.0.0/cc/cpp/Makefile pcc/cc/cpp/Makefile
--- pcc-1.0.0/cc/cpp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ pcc/cc/cpp/Makefile	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,55 @@
+#
+# Copyright (c) 2011 Jiri Zarevucky
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# - Redistributions of source code must retain the above copyright
+#   notice, this list of conditions and the following disclaimer.
+# - Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in the
+#   documentation and/or other materials provided with the distribution.
+# - The name of the author may not be used to endorse or promote products
+#   derived from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+MIPDIR = ../../mip
+ARCHDIR = ../../arch/$(PLATFORM)
+EXTRA_CFLAGS = -I$(MIPDIR) -I$(ARCHDIR) -w
+DEFS = -DCPP_DEBUG -Dfree=free -DCPPBUF=16384
+BINARY = cpp
+
+PRE_DEPEND = compat.c
+EXTRA_CLEAN = compat.c y.tab.c y.tab.h
+
+POSIX_COMPAT = y
+
+YACC = yacc
+
+SOURCES = \
+	y.tab.c \
+	cpp.c \
+	token.c \
+	compat.c
+
+include $(USPACE_PREFIX)/Makefile.common
+
+y.tab.c:
+	$(YACC) -d cpy.y
+
+compat.c: $(MIPDIR)/compat.c
+	ln -s -f $^ $@
+
diff -ur --unidirectional-new-file pcc-1.0.0/cc/cpp/token.c pcc/cc/cpp/token.c
--- pcc-1.0.0/cc/cpp/token.c	2011-03-12 18:08:26.000000000 +0100
+++ pcc/cc/cpp/token.c	2013-09-11 19:46:33.156788000 +0200
@@ -182,7 +182,7 @@
 fastscan(void)
 {
 	struct symtab *nl;
-	int ch, i, ccnt, onemore;
+	int ch, i, ccnt;
 	usch *cp;
 
 	goto run;
@@ -356,7 +356,7 @@
 					ch = NXTCH();
 				goto xloop;
 			}
-			onemore = i = ccnt = 0;
+			i = ccnt = 0;
 			do {
 				yytext[i++] = (usch)ch;
 				ch = NXTCH();
@@ -799,7 +799,8 @@
 		if (++inclevel > MAX_INCLEVEL)
 			error("Limit for nested includes exceeded");
 	} else {
-		ic->infil = 0;
+		error("Reading from stdin is disabled on HelenOS.");
+		ic->infil = fileno(stdin);
 		ic->orgfn = ic->fname = (const usch *)"<stdin>";
 	}
 #ifndef BUF_STACK
diff -ur --unidirectional-new-file pcc-1.0.0/config.h pcc/config.h
--- pcc-1.0.0/config.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/config.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,182 @@
+/* Hard-coded, because wiring up configure script would just not be worth the effort. */
+
+/* Using a.out ABI */
+//#undef AOUTABI
+
+/* Define path to alternate assembler */
+#define ASSEMBLER "/app/as"
+
+/* Using Classic 68k ABI */
+//#undef CLASSIC68K
+
+/* Using COFF ABI */
+//#undef COFFABI
+
+/* Define path to alternate compiler */
+//#undef COMPILER
+
+/* Using ECOFF ABI */
+//#undef ECOFFABI
+
+/* Using ELF ABI */
+#define ELFABI 1
+
+/* Define to 1 if you have the `basename' function. */
+//#define HAVE_BASENAME 1
+
+/* Define to 1 if printf supports C99 size specifiers */
+//#define HAVE_C99_FORMAT 1
+
+/* Define to 1 if your compiler supports C99 variadic macros */
+#define HAVE_CPP_VARARG_MACRO_GCC 1
+
+/* Define to 1 if you have the `ffs' function. */
+#define HAVE_FFS 1
+
+/* Define to 1 if you have the `getopt' function. */
+#define HAVE_GETOPT 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <libgen.h> header file. */
+//#define HAVE_LIBGEN_H 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+//#define HAVE_STRLCAT 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+//#define HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strtold' function. */
+#define HAVE_STRTOLD 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+//#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vfork' function. */
+//#define HAVE_VFORK 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+#ifdef __BE__
+	/* Define if host is BIG endian */
+	#define HOST_BIG_ENDIAN
+	/* Define if target defaults to BIG endian */
+	#undef TARGET_BIG_ENDIAN
+#endif
+
+#ifdef __LE__
+	/* Define if host is LITTLE endian */
+	#define HOST_LITTLE_ENDIAN
+	/* Define if target defaults to LITTLE endian */
+	#define TARGET_LITTLE_ENDIAN
+#endif
+
+/* lex is flex */
+#define ISFLEX 1
+
+/* Define alternate standard lib directory */
+#define LIBDIR "/lib/"
+
+/* Define path to alternate linker */
+#define LINKER "/app/ld"
+
+/* Using Mach-O ABI */
+//#undef MACHOABI
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "<zarevucky.jiri@gmail.com>"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "pcc"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "pcc 1.0.0.RELEASE"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "pcc"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.0.0.RELEASE"
+
+/* Major version no */
+#define PCC_MAJOR 1
+
+/* Minor version no */
+#define PCC_MINOR 0
+
+/* Minor minor version no */
+#define PCC_MINORMINOR 0
+
+/* Using PE/COFF ABI */
+//#undef PECOFFABI
+
+/* Define path to alternate preprocessor */
+#undef PREPROCESSOR
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define alternate standard include directory */
+#define STDINC "/inc/c"
+
+
+/* Target OS */
+#define TARGOS helenos
+
+/* Target OS version */
+#define TARGOSVER 0
+
+/* Enable thread-local storage (TLS). */
+#define TLS 1
+
+/* Version string */
+#define VERSSTR "pcc 1.0.0.RELEASE 20110221 for HelenOS"
+
+/* Size of wide character type */
+#define WCHAR_SIZE 4
+
+/* Type to use for wide characters */
+#define WCHAR_TYPE INT
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+//#define YYTEXT_POINTER 1
+
+#undef COMPILER
+
diff -ur --unidirectional-new-file pcc-1.0.0/mip/config.h pcc/mip/config.h
--- pcc-1.0.0/mip/config.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/mip/config.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,182 @@
+/* Hard-coded, because wiring up configure script would just not be worth the effort. */
+
+/* Using a.out ABI */
+//#undef AOUTABI
+
+/* Define path to alternate assembler */
+#define ASSEMBLER "/app/as"
+
+/* Using Classic 68k ABI */
+//#undef CLASSIC68K
+
+/* Using COFF ABI */
+//#undef COFFABI
+
+/* Define path to alternate compiler */
+//#undef COMPILER
+
+/* Using ECOFF ABI */
+//#undef ECOFFABI
+
+/* Using ELF ABI */
+#define ELFABI 1
+
+/* Define to 1 if you have the `basename' function. */
+//#define HAVE_BASENAME 1
+
+/* Define to 1 if printf supports C99 size specifiers */
+//#define HAVE_C99_FORMAT 1
+
+/* Define to 1 if your compiler supports C99 variadic macros */
+#define HAVE_CPP_VARARG_MACRO_GCC 1
+
+/* Define to 1 if you have the `ffs' function. */
+#define HAVE_FFS 1
+
+/* Define to 1 if you have the `getopt' function. */
+#define HAVE_GETOPT 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <libgen.h> header file. */
+//#define HAVE_LIBGEN_H 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+//#define HAVE_STRLCAT 1
+
+/* Define to 1 if you have the `strlcpy' function. */
+//#define HAVE_STRLCPY 1
+
+/* Define to 1 if you have the `strtold' function. */
+#define HAVE_STRTOLD 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+//#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vfork' function. */
+//#define HAVE_VFORK 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+#ifdef __BE__
+	/* Define if host is BIG endian */
+	#define HOST_BIG_ENDIAN
+	/* Define if target defaults to BIG endian */
+	#undef TARGET_BIG_ENDIAN
+#endif
+
+#ifdef __LE__
+	/* Define if host is LITTLE endian */
+	#define HOST_LITTLE_ENDIAN
+	/* Define if target defaults to LITTLE endian */
+	#define TARGET_LITTLE_ENDIAN
+#endif
+
+/* lex is flex */
+#define ISFLEX 1
+
+/* Define alternate standard lib directory */
+#define LIBDIR "/lib/"
+
+/* Define path to alternate linker */
+#define LINKER "/app/ld"
+
+/* Using Mach-O ABI */
+//#undef MACHOABI
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "<zarevucky.jiri@gmail.com>"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "pcc"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "pcc 1.0.0.RELEASE"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "pcc"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.0.0.RELEASE"
+
+/* Major version no */
+#define PCC_MAJOR 1
+
+/* Minor version no */
+#define PCC_MINOR 0
+
+/* Minor minor version no */
+#define PCC_MINORMINOR 0
+
+/* Using PE/COFF ABI */
+//#undef PECOFFABI
+
+/* Define path to alternate preprocessor */
+#undef PREPROCESSOR
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define alternate standard include directory */
+#define STDINC "/inc/c"
+
+
+/* Target OS */
+#define TARGOS helenos
+
+/* Target OS version */
+#define TARGOSVER 0
+
+/* Enable thread-local storage (TLS). */
+#define TLS 1
+
+/* Version string */
+#define VERSSTR "pcc 1.0.0.RELEASE 20110221 for HelenOS"
+
+/* Size of wide character type */
+#define WCHAR_SIZE 4
+
+/* Type to use for wide characters */
+#define WCHAR_TYPE INT
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+//#define YYTEXT_POINTER 1
+
+#undef COMPILER
+
diff -ur --unidirectional-new-file pcc-1.0.0/os/helenos/ccconfig.h pcc/os/helenos/ccconfig.h
--- pcc-1.0.0/os/helenos/ccconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ pcc/os/helenos/ccconfig.h	2013-09-11 19:46:33.156788000 +0200
@@ -0,0 +1,87 @@
+/*	$Id: ccconfig.h,v 1.19 2010/11/09 08:40:50 ragge Exp $	*/
+
+/*
+ * Copyright (c) 2011 Jiri Zarevucky
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Various settings that controls how the C compiler works.
+ */
+
+/* common cpp predefines */
+#define CPPADD	{ "-D__helenos__", "-D__ELF__", NULL, }
+
+#undef CRT0FILE
+#undef CRT0FILE_PROFILE
+
+#define LIBCLIBS { "/lib/libc.a", "/lib/libsoftfloat.a", "/lib/libsoftint.a", NULL }
+#define LIBCLIBS_PROFILE LIBCLIBS
+
+#define STARTFILES { NULL }
+#define ENDFILES { NULL }
+
+#define STARTFILES_S { NULL }
+#define ENDFILES_S { NULL }
+
+#define STARTLABEL "__entry"
+
+#if defined(mach_ia32)
+#define CPPMDADD { "-D__i386__", NULL, }
+#define DYNLINKER { NULL }
+#elif defined(mach_ppc32)
+#define CPPMDADD { "-D__ppc__", NULL, }
+#define DYNLINKER { NULL }
+#elif defined(mach_amd64)
+#define CPPMDADD { "-D__x86_64__", NULL, }
+#define	DYNLINKER { NULL }
+#elif defined(mach_mips32)
+#define CPPMDADD { "-D__mips__", NULL, }
+#define DYNLINKER { NULL }
+#else
+#error defines for arch missing
+#endif
+
+#ifndef LIBDIR
+#define LIBDIR "/lib/"
+#endif
+
+#ifndef LIBEXECDIR
+#define LIBEXECDIR "/app/"
+#endif
+
+#ifndef STDINC
+#define STDINC "/inc/c/"
+#endif
+
+#ifndef INCLUDEDIR
+#define INCLUDEDIR STDINC
+#endif
+
+#define STABS
+
+#ifndef ELFABI
+#define ELFABI
+#endif
